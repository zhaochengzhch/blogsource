---
title: 漫谈java链路跟踪实现
date: 2019-12-06 22:13:44
tags: java,trace,javaagent,
---


链路跟踪的实现有多种形势，就我所知大概可以分为三大类：
- 针对语言的特定实现

这类方法基本思路是基于字节码增强之类动态代理的方式去无侵入的实现代码注入，在增强点透传数据，从而实现跨实例的信息传递。这类的方法的优势是不需要有遵循固定的规范，拿来即用，接入成本比较低，但是比较trick，各个增强点都注入了代码，有一定风险性，通常只会针对特定语言。如果是小团队想快速尝鲜可以用.[skywalking](https://github.com/apache/skywalking)
- 一类是基于显式代码埋点的.

这类实现通常来说都是大公司，有统一的基础组件部门，有专门负责维护中间件的部门，可以抽象出来一套协议，在各个组件（rpc组件、mq组件和db组件等）中显示代码调用的方式去实现trace。trace的实现依赖于各个组件的协同，优势是安全可靠，但是依赖各个组件的相互配合，有维护、推进成本以及研发门槛，但是效率和可维护性肯定要好很多。大部分都遵循opentracing的规范，以便和各类开源组件对接。[jaeger
](https://github.com/jaegertracing/jaeger)、[CAT](https://github.com/dianping/cat)、[SOFATracer](https://github.com/sofastack/sofa-tracer)、[zipkin](https://github.com/openzipkin/zipkin)、[dapper](https://bigbully.github.io/Dapper-translation/)
- 一类是基于service mesh的方案

当然这种实现都是依赖agent的，模型上看很理想。关键在于service mesh的推进，优点就是service mesh的优点，不依赖具体的语言和协议，缺点是门槛高，成本高。

这里仅仅讨论下科普性质的介绍下javaagent实现的基本原理：

# java版实现链路跟踪的策略

当然每个人对链路跟踪里和看问题的视角不同，设计出来的东西也不一样，这里也仅仅是我的一家之言，依我来看一个完整的链路跟踪项目大概需要分层下面4个部分：

1. 一方面是java-agent的模块，主要作用是注册增强点，在类加载的过程中拦截一些方法。还会有一些其他的功能，比如类隔离，比如启动一些辅助工能够，比如提供http进行监控等等。
2. 字节码编辑模块。这个模块的主要作用就是具体的针对各个增强点实现，这里需要和具体的rpc、协议有关系，需要根据需要选择增强点和增强逻辑的实现。
3. 链路增强的协议设计。这部分主要是根据指链路跟踪的元数据，基本上属于协议层面。典型的比如opetraingAPI，更关注的是可以获取何种数据，此外跟数据分析的部分也是相关的。
3. 链路跟踪的插件设计，这部分主要针对可以根据透传的数据做何种事情，比如如何做压测、如何做请求染色等等。更多的合业务相关。大部分开源方案不涉及但是如果是公司内部开发的话更多改的是这部分代码。

下面我就逐个介绍下这几个模块：

## java-agent模块

### 类加载器的概念

javaer们都知道一个基本的概念叫类加载器。正是因为有类加载，才使得java虽然是一个编译性的语言，但是具有了动态的特性，即使在运行阶段只要重载了类加载器的内容就可以改变代码的逻辑。类加载器的理念使得java有很多骚操作。，比说类隔离[sofa-ark](https://github.com/sofastack/sofa-ark)，比如说热部署[spring-loaded](https://github.com/spring-projects/spring-loaded)，比如故障演练和线上问题排查[jvm-sandbox](https://github.com/alibaba/jvm-sandbox)、[btrace](https://github.com/btraceio/btrace)、[arthas](https://github.com/alibaba/arthas)

那么如何改变类夹在其中的类呢？
总的来说有三类方式：
1. 控制加载类的类加载器，比如tomcat，用自己的类加载器这样就可以热部署，比如sofa-ark有字节的类加载可以隔离各个中间件的实现解决砖石型依赖的问题。
2. 通过javaagent在instrument中拦截类的加载，优点是可以针对所有的类加载实现拦截。
3. 使用特定的jvm实现，这个基本上不可能，即使技术上可能大部分公司也不太可能采用。

从链路跟踪的实现原理来看，2是更好的选择，因为链路跟踪关心的增强点也就是具体的某个方法，至于这个方法是被那个类加载加载的其实没有这么关系。

### 介绍下java-agent的概念

java-agent和service mesh的agent或是日志采集器之类的agent并不是一个概念，java-agent不是一个独立的进程而是一个依附于java进程启动的附属程序。在java启动参数中加入-javaagent并指向一个实现了特定接口的包就可以加入-javagent程序。一个已经运行的java程序也可以通过attchment的方式接入javaagnet。

在java-agent中可以在关联java运行时的instrument，相当于个hook，在每次加载类的过程中做拦截，
在拦截的代码中可以检测到链路跟踪的类，在特定的增强点进行wrap从而实现链路增强。

### 额外的工作
javaagent还有很多地方也有用处，比如说可以在这里构造自己的类加载器，避免污染主线程的类加载过程，比如会引入一些日志包或者特定的三方框架，以及提供一些http端口做一些架空的服务之类的，这里可以看下jvm-sandbox和skywalking的一些实现。

## 字节码编辑方式
### 字节码编辑工具

字节码也许很神奇，但是字节码编辑方式并不神奇，字节码编辑对链路跟踪来说只是一种实现的方式，不用太过纠结。
总的来说有3套工具；
1. ASM系，cglib。基于迭代模式的实现方法。强大而黑盒。动态代理的主要实现方式。
2. javasisit，翻译模式的字节码编辑方式，低门槛的翻译机制，缺点是小概率加载失败，我目前没遇到过。
3. Byte Buddy 提供生成任意类的scheme。

### 增强点的定义和增强逻辑
链路跟踪系统归根到底其实是对跨实例的调用过程进行wrap，从而实现将上下游信息串联起来从而实现无侵入的跨系统的信息传递，当然也可以实现类似的跨线程的信息传递。因此可以将

至于如何找到增强点，其实和具体的rpc框架、http-client、http-service、mq、和数据库驱动有关系。这方面可以参考[skywalking-sniffer](https://github.com/apache/skywalking/tree/master/apm-sniffer)


## 链路跟踪的数据模型
所谓的协议层面，我更多的是想讨论跟通用的数据模型、以及建立在此模型上的链路跟踪实现原理，最后讨论在工程层面的采集传输和数据分析处理和展示：

### 元数据
说到链路跟踪的模型，一个比较公认的模型就是opentracing，opentracing即不是程序代码也不是标准，而是一组api规范，以及相关实现和文档构成的集合。但是其语义大量的影响链路跟踪的实现基本上实际上的是链路跟踪领域的标准。其语义如下[opentracing的语义](https://github.com/opentracing/specification/blob/master/specification.md)

很多链路跟踪的系统都有相似之处。简单的说一次外部调用可以被多个内部请求组合完成，这一过程可以被描述成一个树的形式，而每次调用被定义为一个span。整个调用可以被称为一个trace，有一个唯一id标识。

span是构成调用树的最小单元。通常来说包括下面几个部分，通常也会被一个唯一id标识：
- 操作名，通常是一个pattern，比如调用方法名，比如URL等等。
- 起止时间
- 0个或多个tags，key为string，value，比如ip，app名，数据名、url之类
- 0个或多个log，比如错误码，调用栈、时间消息。
- 0个或多个span的引用，（ChildOf、FollowsFrom）
- SpanContext，(traceid、spanid、sampleFlag、Baggage)是一种概念或者说接口层面的东西。可以用于序列化和反序列化的对象，或是为中间件和业务程序提供瘦api，本身是不可变的。Baggage可以透传用户的kv。

关于traceId和spanId的构造方式其实也是有趣的问题：
一种常见的方式就是构造唯一id。这个网上有很多方案。通常来说是根据一些kv构造，比如说ip、app名、进程名、spanName、时间戳、自增构造唯一数字标志或者长的字符串。只是在字段取舍和长度上有各家的考虑。
但是在spanid的构造上就会有另一种策略，我称之为放弃治疗版本。就是构造成带有链路树结构信息的节点，比如说跟节点就是1，子节点依次为1.1、1.2等等。
这种方式好处是比较明晰，但是我个人还是不太建议主要是2种原因，一个是考虑到followsFrom的概念在这种场景下无法很好的描述。二是在某些特殊的场景下会构造无限长的spanId。比如循环a->b,b->a的情况下，会运行很久后出现故障，而且非常难排查。
而我之所以称之为放弃治疗就是因为这种设计天然的放弃了FollowsFrom的场景。虽然我个人并不赞成，但是在FollowsFrom的场景下是否构造新的链路其实是一个更实质性的问题。我个人是赞成构造新的trace链路的，因为不构造的情况下会导致无法判断一个链路是否已经完成。这虽然并不会影响trace的功能，但是后续数据分析的过程会比较难处理，但是构造新链路又会有截断链路之间的因果关系，一种兼容性的关系是采用弱化的构造。比如kafka投递的过程中虽然重新构造spanid但是logid不变，使用一个不变的logid来关联2个trace。


### rpc调用的过程，日志的恢复
其实透过上文的内容我们就比较容易理解了，trace本身传递的就是spanContext，一个运行时系统的内存对象在跨线程或者跨实例传递的过程中会按照特定的序列化方式转换成可以被特定载荷理解的附加内容传递，比如说http-header，dubbo的attachment、kafka的attachment等。所以所有发送和接受，rpc和mq的地方都会被代码增强，拦截对应的方法从而实现spanContext和内存对象的转换。


对于跨线程的传递方式，通常来说稍微麻烦一些，java的话通常来说可以这样做，

通常来说包装一下Runable和Callable，添加一个额外的field比如说context之类的建造新类traceRunnable
在拦截一下thread对象和线程池对象的提交方法，在提交的过程中提交一个将task的上下文spanContext转换成field对象，并和原本的task对象一起构造成成TraceRunnable，所以提交的并非是runnable而是TraceRunnable

在真实运行程序的过程中，拦截一下run方法，在run之间加入类似rpc和mq的恢复过程就可以将trace的信息透传到其他线程中。

go 的话也可以用类似的思路，简单的说将go function 做成模板的形势，但是依赖于用户显式调用。

### 元数据的采样、分析和存储。
trace的采集和日志的采集没有特别大的区别，整体可以采用ELK技术栈。
采集方面：
通常来说trace的采集都是head-base的就是在根节点确定是否需要采集，trace本身需要采样否则数据量会比较大，大部分trace采样率都很低，1%的级别比较常见。
简单粗暴的话可以直接通过java-agent中传递到mq不落盘，如果落盘采集的话，由于trace格式本身是格式化的，也建议格式化落盘，
通道可以用kafka

存储方面：
存储比较常见的是直接用es，因为trace通常涉及到大量的搜索，而且没有修改数据用es比较合理。但是es本身成本是比较高的，而且再常见的trace查询模型下，通常是根据某些参数搜寻到traceId。再根据traceid索引出整条链路，所以将可以将整个span或者trace放入habse，将可索引项放入es也是可选的方式。这里主要的问题是每一行是span信息，而用户想搜索的是trace信息这里也是很矛盾的场景。个人觉得这里有很多可以优化的点。网上也没有太多人讨论。

分析方面：
trace的数据可以应用的场景有很多，举2个例子，
性能分析：
由于被采样的链路整个链路的各个调用的起止时间都有，所以分析一次用户请求的耗时缺点在哪里就比较容易，筛选出入口链路和耗时比较长的链路然后观察下就号，比如那些接口可以改成批量、那些sql比较慢，或者调用顺序或是层级上可以优化等等，尤其是压测的时候比较合适。因为
应用分级：
业务比较复杂的时候往往需要应用拆分，以避免反向依赖或者不科学的调用关系，梳理一些rpc超时的配置是否合理，或者某些重要接口是否有依赖次一级的应用，让开发去梳理往往是非常复杂的，一方面是链路太复杂，另一方也不可靠。
可以根据trace链路梳理出来全部的应用及接口及的请求来实现更有效。


## trace的拓展能力
上面的内容实现了一个基本的trace组件，但是距离服务与公司还是比较难得。trace的核心能力在跨系统透传信息，在此基础上可以做很多的事情，这部分代码通常来说是比较容易变化的版本，最好也是隔离出来。
trace的代码设计需要做2层基本的抽象，一层抽象是针对上第二小节说明的针对各个组件的代码抽象，因为不同中间件的序列化和反序列化方式肯定是不同的，这个基本上大家很容就理解了。另一层就是在这里，针对插件的实现实际上也需要一层抽象，因为不同的功能影响的中间件不一样的。当然更好的一种方式是讲这部分代码拆分到各个组件中去实现。但并非所有的功能都依赖于三方组件，trace本身代码层面的隔离也很重要。这里的设计比较难抽象描述。我们可以看一个例子。

### 环境隔离（请求染色）
首先介绍下环境隔离的概念：大部分的开发模式都是基于giflow的。如果只有一套环境的话就会有多个代码合并的蛋疼问题，如果建多套环境的话成本有很高（比如独立的数据库，Nginx、注册中心、redis），那有没有一种方式既可以创建创建多套环境又避免蛋疼的产品问题呢？当然有！也就请求染色。

请求染色的方案就是trace在各个中间件请求下解析出入口环境信息，并且将其作为参数透传，各个中间件组件配合该信息将trace路由到对应集群上的方案：举一个简单的例子如下所示：

![](images/漫谈java链路跟踪实现/Lark20191208205450.png)

基本的思路就是这样，所有集群都有一套基准环境，通常部署master分支，而本次分支设计到的变革部署一套feature集群。比如图中的app2、app4、app6等。所有的公共组件都用同一套，比如Nginx、注册中心、数据库、kafka集群等等。但是应用用到的资源会略有区别，比如说注册中心上带有集群的环境信息，rds可以建一个带有环境名后缀的影子表。kafka建有对应环境名后缀的topic。
用户请求的时候使用相同的域名但是待上具有环境名的header，app在接受请求的时候会解析header并将入口环境信息放入baaage中，该信息会随链路下传。

对于rpc，客户端做路由的时候会根据环境信息优先选取特定子环境的集群，如果没有则调用基准环境，基准环境中的应用在调用的时候也可以根据相同的规则优先调用子环境。即使调用穿过了中间件比如队列，则传递的消息也负有环境信息，trace也可以根据信息解析出路由规则并进行透传。不过为了避免消息被基准环境的app消费还是需要建特定子环境的topic。


## 其他
业务监控指标计算。
gossip协议的注册中心实现
类隔离和中间件自动升级
环境隔离的方案、
devops的方案。
双机房的方案
容器化
Tair缓存的框架和优化。
